<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PDF RAG MVP</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <div class="container">
    <h1>PDF RAG MVP</h1>
    <div class="controls">
      <button id="ingest">Build Index</button>
      <input id="q" type="text" placeholder="Ask something…" />
      <select id="mode">
        <option value="matches">Closest matches</option>
        <option value="rag">Light RAG</option>
      </select>
      <button id="ask">Search</button>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>Answer</h2>
        <pre id="answer"></pre>
      </div>
      <div class="panel">
        <h2>Evidence</h2>
        <div id="results"></div>
      </div>
      <!-- Replace the old iframe panel with this -->
        <div class="panel">
            <h2>PDF</h2>
            <div id="pdfStage" class="pdf-stage">
            <img id="pdfImg" alt="PDF Page" />
            <svg id="pdfOverlay" class="pdf-overlay"></svg>
            </div>
            <div class="zoom-bar">
            <button id="zoomOut">−</button>
            <span id="zoomLabel">100%</span>
            <button id="zoomIn">+</button>
            </div>
        </div>
  
    </div>
  </div>

  <script>
    const ingestBtn = document.getElementById('ingest');
    const askBtn = document.getElementById('ask');
    const q = document.getElementById('q');
    const mode = document.getElementById('mode');
    const answer = document.getElementById('answer');
    const results = document.getElementById('results');
    const pdf = document.getElementById('pdf');

    ingestBtn.onclick = async () => {
      ingestBtn.disabled = true;
      const res = await fetch('/ingest', {method: 'POST'});
      const j = await res.json();
      alert(j.status ? 'Index ready.' : 'Ingest failed.');
      ingestBtn.disabled = false;
    };

    askBtn.onclick = async () => {
      results.innerHTML = '';
      answer.textContent = 'Thinking…';
      const m = mode.value;
      const endpoint = m === 'matches' ? '/answer?mode=matches' : '/answer?mode=rag';
      const res = await fetch(endpoint + '&query=' + encodeURIComponent(q.value));
      const j = await res.json();
      answer.textContent = j.answer || '';
      (j.hits || []).forEach(h => {
        const div = document.createElement('div');
        div.className = 'hit';
        const a = document.createElement('a');
        a.href = h.citation_url;
        a.target = 'pdf';
        a.textContent = `p.${h.page}`;
        a.onclick = () => { pdf.src = h.citation_url; };
        div.innerHTML = `
          <div><b>${h.kind}</b> – score ${h.score.toFixed(3)}</div>
          <div>Page: </div>
        `;
        div.children[1].appendChild(a);
        results.appendChild(div);
      });
      // auto-focus PDF on first hit
      if (j.hits && j.hits[0]) pdf.src = j.hits[0].citation_url;
    };
  const pdfImg = document.getElementById('pdfImg');
  const pdfOverlay = document.getElementById('pdfOverlay');
  const pdfStage = document.getElementById('pdfStage');
  const zoomIn = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');
  const zoomLabel = document.getElementById('zoomLabel');

  // Simple zoom (CSS scale of the image & overlay together)
  let zoom = 1.0;
  function applyZoom() {
    pdfImg.style.transform = `scale(${zoom})`;
    pdfOverlay.style.transform = `scale(${zoom})`;
    pdfOverlay.style.transformOrigin = 'top left';
    zoomLabel.textContent = `${Math.round(zoom * 100)}%`;
  }
  zoomIn.onclick = () => { zoom = Math.min(3, zoom * 1.2); applyZoom(); };
  zoomOut.onclick = () => { zoom = Math.max(0.25, zoom / 1.2); applyZoom(); };

  // Load a page image and size the overlay to match the *natural* image dimensions
  async function showPage(pageNum) {
    const src = `/page_image?page=${pageNum}`;
    // clear overlay
    pdfOverlay.innerHTML = '';
    // load image
    await new Promise((resolve, reject) => {
      pdfImg.onload = () => resolve();
      pdfImg.onerror = reject;
      pdfImg.src = src;
    });
    // Set SVG overlay to match the rendered image size, but use a viewBox
    // to keep the coordinate system the same as the natural image dimensions.
    const rect = pdfImg.getBoundingClientRect();
    pdfOverlay.setAttribute('viewBox', `0 0 ${pdfImg.naturalWidth} ${pdfImg.naturalHeight}`);
    pdfOverlay.setAttribute('width', String(rect.width));
    pdfOverlay.setAttribute('height', String(rect.height));
    pdfOverlay.style.width = rect.width + 'px';
    pdfOverlay.style.height = rect.height + 'px';

    // Make overlay exactly overlap the image
    pdfOverlay.style.position = 'absolute';
    pdfOverlay.style.left = pdfImg.offsetLeft + 'px';
    pdfOverlay.style.top = pdfImg.offsetTop + 'px';
    // Reset zoom after new image
    zoom = 1.0;
    applyZoom();
  }

  // Draw highlight rectangle from bbox_px (in 300dpi pixels)
  function drawHighlight(bbox_px) {
    if (!bbox_px) return;
    const [x0, y0, x1, y1] = bbox_px.map(Number);
    const rectEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectEl.setAttribute('x', String(x0));
    rectEl.setAttribute('y', String(y0));
    rectEl.setAttribute('width', String(Math.max(1, x1 - x0)));
    rectEl.setAttribute('height', String(Math.max(1, y1 - y0)));
    rectEl.setAttribute('class', 'highlight-rect');
    pdfOverlay.appendChild(rectEl);

    // Auto scroll: ensure highlighted area is visible.
    // This needs to be scaled from natural coordinates to displayed coordinates.
    const scale = pdfImg.getBoundingClientRect().width / pdfImg.naturalWidth;
    const pad = 40;
    const targetX = (x0 * scale * zoom) - pad;
    const targetY = (y0 * scale * zoom) - pad;
    pdfStage.scrollTo({ left: Math.max(0, targetX), top: Math.max(0, targetY), behavior: 'smooth' });
  }

  // Hook into the existing hit click flow
  function showHit(h) {
    // 1) ensure page image is loaded
    showPage(h.page).then(() => {
      // 2) draw the highlight
      drawHighlight(h.bbox_px);
    });
  }

  // Patch the earlier results rendering to use showHit()
  // (Replace the a.onclick part in your previous code)
  function renderResults(hits) {
    results.innerHTML = '';
    if (!hits || !hits.length) return;

    hits.forEach(h => {
      const div = document.createElement('div');
      div.className = 'hit';
      const btn = document.createElement('button');
      btn.textContent = `Show p.${h.page}`;
      btn.onclick = () => showHit(h);

      const snippet = document.createElement('div');
      snippet.textContent = (h.text || `${h.kind} hit`);

      const meta = document.createElement('div');
      meta.style.fontSize = '12px';
      meta.style.opacity = '0.8';
      meta.textContent = `score=${h.score?.toFixed?.(3) ?? ''}`;

      div.appendChild(btn);
      div.appendChild(snippet);
      div.appendChild(meta);
      results.appendChild(div);
    });

    // Auto show first
    showHit(hits[0]);
  }

  // Replace the onClick block in your askBtn handler:
  askBtn.onclick = async () => {
    results.innerHTML = '';
    answer.textContent = 'Thinking…';
    const m = mode.value;
    const endpoint = m === 'matches' ? '/answer?mode=matches' : '/answer?mode=rag';
    const res = await fetch(endpoint + '&query=' + encodeURIComponent(q.value));
    const j = await res.json();
    answer.textContent = j.answer || '';
    renderResults(j.hits || []);
  };
</script>

</body>
</html>
